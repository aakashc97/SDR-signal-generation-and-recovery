# -*- coding: utf-8 -*-
"""CDR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U1cCFJ32rcBxXzGBRI44ewfeL9dgdihR
"""

from pathlib import Path
from matplotlib import pyplot as plt
data = Path('CH2_1.1V.FLT').read_bytes()
import struct
length = len(data)
#print(length)
voltage = []
var_calc = []
var_list = []
j=0
ones=0
zeros=0
for i in range(0,length,4):
  ints = struct.unpack('>f', data[i:i+4])
  voltage.append(ints[0])
  #print(voltage[j])

  j=j+1
voltage = voltage[200000:]
print(len(voltage))
plt.plot(voltage)
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.show()
plt.plot(voltage[800000:830000])
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.show()

plt.plot(voltage[200000:300000])
plt.show()



import numpy as np
from tqdm import tqdm
#finding slope
slope = []
slope_threshold = []
slope_index = []

for i in range(0,len(voltage)-1):
  slope.append(voltage[i+1]-voltage[i])

#finding indices where slope went over threshold

for i in range(0,len(slope)):
  if ((abs(slope[i]))>=0.021):
    slope_threshold.append(1)

  else:
    slope_threshold.append(0)

plt.plot(voltage,label="voltage")
plt.plot(slope_threshold,label="edge detected")
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.legend()
plt.show()

plt.plot(voltage[800000:802000],label="voltage")
plt.plot(slope_threshold[800000:802000],label="edge detected")
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.legend()
plt.show()
test=[]


for i in tqdm(range(0,len(slope_threshold)-1001)):
  test=np.max(np.abs(voltage[i:i+1000]))
  if (test<0.07):
    slope_threshold[i]=0

plt.plot(voltage,label="voltage")
plt.plot(slope_threshold,label="edge detected")
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.legend()
plt.show()

plt.plot(voltage[800000:810000],label="voltage")
plt.plot(slope_threshold[800000:810000],label="edge detected")
plt.ylabel("Voltage (in V)")
plt.xlabel("Number of samples")
plt.legend()
plt.show()

for i in range(0,len(slope_threshold)):
  if (slope_threshold[i]==1):
    slope_index.append(i)

"""
print(slope_index[len(slope_index)-100:])
max=0
for i in range (391800,391950):
  if (slope[i]>max):
    max=slope[i]
print(max)
"""



#filtering the clusters of 1 and replacing the cluster with one 1
first_index = slope_index[0]
last_index = 0
for i in range (0,len(slope_index)-1):
  slope_of_index = slope_index[i+1]-slope_index[i]

  if (slope_of_index > 200):

    last_index = slope_index[i]
    mid_index = round((last_index + first_index)/2)
    slope_threshold[mid_index] = 1
    for j in range (first_index,last_index + 1):
      if (j != mid_index):
        slope_threshold[j] = 0
    first_index = slope_index[i+1]
  if (i==len(slope_index)-2 ):
    last_index = slope_index[i+1]
    mid_index = round((last_index + first_index)/2)
    slope_threshold[mid_index] = 1
    for j in range (first_index,last_index + 1):
      if (j != mid_index):
        slope_threshold[j] = 0
    #first_index = slope_index_one[i+1]
print(slope_threshold[len(slope_threshold)-1000:])

slope_index_filtered=[]
for i in range(0,len(slope_threshold)):
  if(slope_threshold[i]==1):
    slope_index_filtered.append(i)
print(slope_index_filtered)

count=0
for i in range (548000,566000):
  if (slope_threshold[i]==1):
    count=count+1
print(count)

plt.plot(voltage[548000:566000])
plt.plot(slope_threshold[548000:566000])
plt.show()



#finding clock frequency
import math
clock = []
clock_index = []


clock = slope_threshold[slope_index_filtered[0]:slope_index_filtered[40]];
for i in range(0,len(clock)):
  if (clock[i] == 1):
    clock_index.append(i)
plt.plot(clock)
plt.show()

print(clock_index)


for i in range(0,len(clock_index)-1):
  gap = clock_index[i+1]-clock_index[i]
  interval = round(gap/20)
  for j in range(1,20):
    clock[clock_index[i]+interval*j]=1

print(clock)
plt.plot(clock[0:1000])
plt.show()
clock_freq=0
clock_index_final = []
for i in range(0,len(clock)):
  if(clock[i]==1):
    clock_index_final.append(i)
print(clock_index_final)
clock_freq=0
for i in range(0,len(clock_index_final)-1):
  clock_freq=clock_freq+(clock_index_final[i+1]-clock_index_final[i])
clock_freq=round(clock_freq/(len(clock_index_final)-1))
print(clock_freq)

first_index_clock=slope_index_filtered[0]
last_index_clock=slope_index_filtered[40]

first_index_main_data=slope_index_filtered[41]
last_index_main_data=slope_index_filtered[len(slope_index_filtered)-1]

#recovering bits
data=0
recovered_bits = []
gap=20
clock_index=[]
for i in range(first_index_main_data,last_index_main_data-gap,gap):
  clock_index.append(i)

for i in range(0,len(clock_index)):
  if (i==len(clock_index)):
    data=(voltage[clock_index[i]+10])
  else:
    data=(voltage[clock_index[i]+10])
  if (data>0):
    recovered_bits.append(1)
  else:
    recovered_bits.append(0)
print(recovered_bits)

print(clock_index[len(clock_index)-1])
print(len(clock_index))
print(slope_index_filtered)
for i in range (0,42):
  diff=slope_index_filtered[i+1]-slope_index_filtered[i]
  if diff < 380 or diff >420:
    print(i," ")

#checking for error rate

import struct

# Open the binary file in read binary mode
with open('random_ampl_30000_10BPS.bin', 'rb') as file:
    # Read all the bytes from the file
    binary_data = file.read()

# Define the format of the binary data (in this case, we assume the data is a sequence of 32-bit integers)
format_string = '<' + str(len(binary_data)//4) + 'i' # '<' is for little-endian byte order, 'i' is for integer

# Unpack the binary data into a tuple of integers
unpacked_data = struct.unpack(format_string, binary_data)

# Convert the tuple to a list
integer_list = list(unpacked_data)

# Print the list of integers
print(integer_list[len(integer_list)-1000:])
print(len(integer_list))
print(len(recovered_bits))
print()

bits=[]
errors=0
for i in range(0,len(recovered_bits)):
  if (recovered_bits[i]==1):
    bits.append(-30000)
  else:
    bits.append(30000)

for i in range(0,len(bits)):
  if(bits[i]!=integer_list[i+1000]):
    errors=errors+1
print(errors/len(bits)*100)
print(integer_list[1000:])
print(bits)

plt.plot(bits)
plt.show()
plt.plot(integer_list[1000:])
plt.show()

print(len(bits))
print(len(integer_list[1000:]))

#plotting error rate vs bits per symbol and error rate vs baud rate for various observations
import matplotlib.pyplot as plt
error=[0.09,0.1,0.11,0.43,0.62]
bps=[12500000,16666667,25000000,50000000,125000000]
plt.plot(bps,error)
plt.ylabel("Error rate (%)")
plt.xlabel("Baud Rate")
plt.show()

import matplotlib.pyplot as plt
error=[3.3,2.9,1.2,0.8,0.57,0.23,0.14]
vpp=[0.94,0.98,1.02,1.06,1.10,1.14,1.18]
plt.plot(vpp,error)
plt.ylabel("Error rate (%)")
plt.xlabel("Peak-to-peak Voltage (V)")
plt.show()

